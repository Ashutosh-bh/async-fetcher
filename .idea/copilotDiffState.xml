<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/async/fetcher_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/async/fetcher_test.go" />
              <option name="originalContent" value="package async&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;func fetchUser(ctx context.Context, id int) (string, error) {&#10;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;if id &lt;= 0 {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;invalid user ID&quot;)&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;user-%d&quot;, id), nil&#10;}&#10;&#10;func TestFetcher_Success(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, 5).Run(ctx)&#10;&#10;&#9;for i := 0; i &lt; 5; i++ {&#10;&#9;&#9;val, err := f.Await()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if val != &quot;user-5&quot; {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected 'user-5', got %v&quot;, val)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_Error(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, -1).Run(ctx)&#10;&#9;val, err := f.Await()&#10;&#9;if err == nil {&#10;&#9;&#9;t.Error(&quot;expected error, got nil&quot;)&#10;&#9;}&#10;&#9;if val != &quot;&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected empty value, got %v&quot;, val)&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_Panic(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;panicFn := func(ctx context.Context, a int) (string, error) {&#10;&#9;&#9;panic(&quot;boom&quot;)&#10;&#9;}&#10;&#9;f := Async(panicFn, 1).Run(ctx)&#10;&#9;val, err := f.Await()&#10;&#9;if err == nil {&#10;&#9;&#9;t.Error(&quot;expected error from panic, got nil&quot;)&#10;&#9;}&#10;&#9;if err != nil &amp;&amp; !contains(err.Error(), &quot;panic recovered&quot;) {&#10;&#9;&#9;t.Errorf(&quot;expected panic recovered in error, got %v&quot;, err)&#10;&#9;}&#10;&#9;if val != &quot;&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected empty value, got %v&quot;, val)&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_AwaitBeforeRun_Panics(t *testing.T) {&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r == nil {&#10;&#9;&#9;&#9;t.Error(&quot;expected panic when Await called before Run&quot;)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#9;f := Async(fetchUser, 1)&#10;&#9;_, _ = f.Await()&#10;}&#10;&#10;func TestFetcher_ConcurrentAwait(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, 7).Run(ctx)&#10;&#9;done := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;val, err := f.Await()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if val != &quot;user-7&quot; {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected 'user-7', got %v&quot;, val)&#10;&#9;&#9;}&#10;&#9;&#9;close(done)&#10;&#9;}()&#10;&#9;val, err := f.Await()&#10;&#9;if err != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;}&#10;&#9;if val != &quot;user-7&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected 'user-7', got %v&quot;, val)&#10;&#9;}&#10;&#9;&lt;-done&#10;}&#10;&#10;func TestMultipleFetchers_RunInParallel(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;start := time.Now()&#10;&#10;&#9;f1 := Async(fetchUser, 1).Run(ctx)&#10;&#9;f2 := Async(fetchUser, 2).Run(ctx)&#10;&#9;f3 := Async(fetchUser, 3).Run(ctx)&#10;&#10;&#9;// Await all&#10;&#9;_, err1 := f1.Await()&#10;&#9;_, err2 := f2.Await()&#10;&#9;_, err3 := f3.Await()&#10;&#10;&#9;if err1 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f1, got %v&quot;, err1)&#10;&#9;}&#10;&#9;if err2 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f2, got %v&quot;, err2)&#10;&#9;}&#10;&#9;if err3 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f3, got %v&quot;, err3)&#10;&#9;}&#10;&#10;&#9;elapsed := time.Since(start)&#10;&#9;if elapsed.Milliseconds() &gt;= 102 {&#10;&#9;&#9;t.Errorf(&quot;fetchers should run in parallel, took %dms&quot;, elapsed.Milliseconds())&#10;&#9;}&#10;}&#10;&#10;// contains checks if substr is in s&#10;func contains(s, substr string) bool {&#10;&#9;return len(substr) == 0 || (len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(s) &gt; len(substr) &amp;&amp; (contains(s[1:], substr) || contains(s[:len(s)-1], substr))))&#10;}&#10;" />
              <option name="updatedContent" value="package async&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;func fetchUser(ctx context.Context, id int) (string, error) {&#10;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;if id &lt;= 0 {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;invalid user ID&quot;)&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;user-%d&quot;, id), nil&#10;}&#10;&#10;func TestFetcher_Success(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, 5).Run(ctx)&#10;&#10;&#9;for i := 0; i &lt; 5; i++ {&#10;&#9;&#9;val, err := f.Await()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if val != &quot;user-5&quot; {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected 'user-5', got %v&quot;, val)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_Error(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, -1).Run(ctx)&#10;&#9;val, err := f.Await()&#10;&#9;if err == nil {&#10;&#9;&#9;t.Error(&quot;expected error, got nil&quot;)&#10;&#9;}&#10;&#9;if val != &quot;&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected empty value, got %v&quot;, val)&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_Panic(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;panicFn := func(ctx context.Context, a int) (string, error) {&#10;&#9;&#9;panic(&quot;boom&quot;)&#10;&#9;}&#10;&#9;f := Async(panicFn, 1).Run(ctx)&#10;&#9;val, err := f.Await()&#10;&#9;if err == nil {&#10;&#9;&#9;t.Error(&quot;expected error from panic, got nil&quot;)&#10;&#9;}&#10;&#9;if err != nil &amp;&amp; !contains(err.Error(), &quot;panic recovered&quot;) {&#10;&#9;&#9;t.Errorf(&quot;expected panic recovered in error, got %v&quot;, err)&#10;&#9;}&#10;&#9;if val != &quot;&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected empty value, got %v&quot;, val)&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_AwaitBeforeRun_Panics(t *testing.T) {&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r == nil {&#10;&#9;&#9;&#9;t.Error(&quot;expected panic when Await called before Run&quot;)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#9;f := Async(fetchUser, 1)&#10;&#9;_, _ = f.Await()&#10;}&#10;&#10;func TestFetcher_ConcurrentAwait(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;f := Async(fetchUser, 7).Run(ctx)&#10;&#9;done := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;val, err := f.Await()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if val != &quot;user-7&quot; {&#10;&#9;&#9;&#9;t.Errorf(&quot;expected 'user-7', got %v&quot;, val)&#10;&#9;&#9;}&#10;&#9;&#9;close(done)&#10;&#9;}()&#10;&#9;val, err := f.Await()&#10;&#9;if err != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error, got %v&quot;, err)&#10;&#9;}&#10;&#9;if val != &quot;user-7&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected 'user-7', got %v&quot;, val)&#10;&#9;}&#10;&#9;&lt;-done&#10;}&#10;&#10;func TestMultipleFetchers_RunInParallel(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;start := time.Now()&#10;&#10;&#9;f1 := Async(fetchUser, 1).Run(ctx)&#10;&#9;f2 := Async(fetchUser, 2).Run(ctx)&#10;&#9;f3 := Async(fetchUser, 3).Run(ctx)&#10;&#10;&#9;// Await all&#10;&#9;_, err1 := f1.Await()&#10;&#9;_, err2 := f2.Await()&#10;&#9;_, err3 := f3.Await()&#10;&#10;&#9;if err1 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f1, got %v&quot;, err1)&#10;&#9;}&#10;&#9;if err2 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f2, got %v&quot;, err2)&#10;&#9;}&#10;&#9;if err3 != nil {&#10;&#9;&#9;t.Errorf(&quot;expected no error for f3, got %v&quot;, err3)&#10;&#9;}&#10;&#10;&#9;elapsed := time.Since(start)&#10;&#9;if elapsed.Milliseconds() &gt;= 102 {&#10;&#9;&#9;t.Errorf(&quot;fetchers should run in parallel, took %dms&quot;, elapsed.Milliseconds())&#10;&#9;}&#10;}&#10;&#10;func TestFetcher_PanicHandlersCalled(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;called := false&#10;&#9;var recoveredValue interface{}&#10;&#9;handler := func(_ context.Context, r interface{}) {&#10;&#9;&#9;called = true&#10;&#9;&#9;recoveredValue = r&#10;&#9;}&#10;&#9;SetPanicHandlers(handler)&#10;&#10;&#9;panicFn := func(ctx context.Context, a int) (string, error) {&#10;&#9;&#9;panic(&quot;custom panic value&quot;)&#10;&#9;}&#10;&#9;f := Async(panicFn, 1).Run(ctx)&#10;&#9;_, err := f.Await()&#10;&#9;if !called {&#10;&#9;&#9;t.Error(&quot;expected panic handler to be called&quot;)&#10;&#9;}&#10;&#9;if recoveredValue != &quot;custom panic value&quot; {&#10;&#9;&#9;t.Errorf(&quot;expected recovered value to be 'custom panic value', got %v&quot;, recoveredValue)&#10;&#9;}&#10;&#9;if err == nil || err.Error() == &quot;&quot; {&#10;&#9;&#9;t.Error(&quot;expected error from panic, got nil or empty error&quot;)&#10;&#9;}&#10;&#9;SetPanicHandlers() // reset handlers&#10;}&#10;&#10;func TestFetcher_MultiplePanicHandlers(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#9;called1 := false&#10;&#9;called2 := false&#10;&#9;handler1 := func(_ context.Context, r interface{}) { called1 = true }&#10;&#9;handler2 := func(_ context.Context, r interface{}) { called2 = true }&#10;&#9;SetPanicHandlers(handler1, handler2)&#10;&#10;&#9;panicFn := func(ctx context.Context, a int) (string, error) {&#10;&#9;&#9;panic(&quot;multi panic&quot;)&#10;&#9;}&#10;&#9;f := Async(panicFn, 1).Run(ctx)&#10;&#9;_, _ = f.Await()&#10;&#9;if !called1 || !called2 {&#10;&#9;&#9;t.Error(&quot;expected both panic handlers to be called&quot;)&#10;&#9;}&#10;&#9;SetPanicHandlers() // reset handlers&#10;}&#10;&#10;// contains checks if substr is in s&#10;func contains(s, substr string) bool {&#10;&#9;return len(substr) == 0 || (len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(s) &gt; len(substr) &amp;&amp; (contains(s[1:], substr) || contains(s[:len(s)-1], substr))))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>